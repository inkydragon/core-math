/* Correctly rounded log2l function for binary64 values.

Copyright (c) 2024 Alexei Sibidanov and Paul Zimmermann

This file is part of the CORE-MATH project
(https://core-math.gitlabpages.inria.fr/).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define TRACE 0x2.80db343f62ef7b4p-16385l

#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <fenv.h>

#ifdef __x86_64__
#include <x86intrin.h>
#endif

// Warning: clang also defines __GNUC__
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic ignored "-Wunknown-pragmas"
#endif

#pragma STDC FENV_ACCESS ON

// anonymous structs, see https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p19
typedef union {
  long double f;
  struct __attribute__((__packed__)) {uint64_t m; uint32_t e:16; uint32_t empty:16;};
} b96u96_u;

typedef union {double f;uint64_t u;} b64u64_u;

static long double __attribute__((noinline)) as_log2_exact(int e){return e;}

// Multiply exactly a and b, such that *hi + *lo = a * b.
static inline void a_mul_double (double *hi, double *lo, double a, double b) {
  *hi = a * b;
  *lo = __builtin_fma (a, b, -*hi);
}

// Multiply (approximately) ah + al by b, and put the result in hi + lo
static inline void s_mul_double (double *hi, double *lo, double ah, double al,
                                 double b)
{
  a_mul_double (hi, lo, ah, b);
  *lo = __builtin_fma (al, b, *lo);
}

// Returns (ah + al) * (bh + bl) - (al * bl)
// We can ignore al * bl when assuming al <= ulp(ah) and bl <= ulp(bh)
static inline void d_mul_double (double *hi, double *lo, double ah, double al,
                                 double bh, double bl) {
  double s, t;

  a_mul_double (hi, &s, ah, bh);
  t = __builtin_fma (al, bh, s);
  *lo = __builtin_fma (ah, bl, t);
}

/* s + t <- a + b, assuming |a| >= |b| */
static inline void
fast_two_sum_double (double *s, double *t, double a, double b)
{
  *s = a + b;
  double e = *s - a;
  *t = b - e;
}

/* For -37 <= i <= 26, T1[i+37] contains {r, h, l} such that
   for xmin := 1+i/128 <= x < xmax := 1+(i+1)/128 for -37 <= i <= -1,
       xmin := 1+i/64 <= x < xmax := 1+(i+1)/64 for 0 <= i <= 26,
   r is the 6-bit approximation minimizing max(abs(r*x-1))
   for xmin <= x < xmax,
   h approximates -log2(r) to nearest, with h multiple of 2^-38, and
   l approximates -log2(r)-h to nearest, with
   |h + l + log2(r)| < 2^-97.91.
   Ensures 0.982666015625000 <= r*h <= 1.01684570312500.
   Table generated by T1() from log2l.sage. */
static const double T1[64][3] = {                                              
   {0x1.68p+0, -0x1.f7a8568cbp-2, -0x1.b3b3864c60011p-44}, /* i=-37 */
   {0x1.6p+0, -0x1.d6753e033p-2, 0x1.5f101c141e67p-42}, /* i=-36 */
   {0x1.6p+0, -0x1.d6753e033p-2, 0x1.5f101c141e67p-42}, /* i=-35 */
   {0x1.58p+0, -0x1.b47ebf739p-2, 0x1.f57d6fae441c1p-40}, /* i=-34 */
   {0x1.58p+0, -0x1.b47ebf739p-2, 0x1.f57d6fae441c1p-40}, /* i=-33 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-32 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-31 */
   {0x1.5p+0, -0x1.91bba891fp-2, -0x1.708b4b2b5056cp-42}, /* i=-30 */
   {0x1.48p+0, -0x1.6e221cd9dp-2, -0x1.9bcaf1aa4168ap-43}, /* i=-29 */
   {0x1.48p+0, -0x1.6e221cd9dp-2, -0x1.9bcaf1aa4168ap-43}, /* i=-28 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-27 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-26 */
   {0x1.4p+0, -0x1.49a784bcdp-2, -0x1.b8afe492bf6ffp-42}, /* i=-25 */
   {0x1.38p+0, -0x1.24407ab0ep-2, -0x1.ce60916e52e91p-44}, /* i=-24 */
   {0x1.38p+0, -0x1.24407ab0ep-2, -0x1.ce60916e52e91p-44}, /* i=-23 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-22 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-21 */
   {0x1.3p+0, -0x1.fbc16b902p-3, -0x1.a0288ea36662ap-41}, /* i=-20 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-19 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-18 */
   {0x1.28p+0, -0x1.acf5e2db4p-3, -0x1.d927dfc23d978p-40}, /* i=-17 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-16 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-15 */
   {0x1.2p+0, -0x1.5c01a39fcp-3, 0x1.4bc302ffa76fbp-42}, /* i=-14 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-13 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-12 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-11 */
   {0x1.18p+0, -0x1.08c588cdap-3, -0x1.e78e589ef1bf4p-41}, /* i=-10 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-9 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-8 */
   {0x1.1p+0, -0x1.663f6fac8p-4, -0x1.13167ccc53826p-40}, /* i=-7 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-6 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-5 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-4 */
   {0x1.08p+0, -0x1.6bad3759p-5, 0x1.0278cec9f90f7p-41}, /* i=-3 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=-2 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=-1 */
   {0x1p+0, 0x0p+0, 0x0p+0}, /* i=0 */
   {0x1.f8p-1, 0x1.743ee862p-6, -0x1.95539356f93dcp-43}, /* i=1 */
   {0x1.fp-1, 0x1.77394c9d8p-5, 0x1.58d55de5c381p-41}, /* i=2 */
   {0x1.e8p-1, 0x1.1bb32a6p-4, 0x1.52743318a8a57p-42}, /* i=3 */
   {0x1.ep-1, 0x1.7d60496dp-4, -0x1.12ce6312ebb82p-42}, /* i=4 */
   {0x1.d8p-1, 0x1.e0b1ae8f4p-4, -0x1.02a99b4c5a725p-40}, /* i=5 */
   {0x1.dp-1, 0x1.22dadc2acp-3, -0x1.96d25a5b8a19bp-40}, /* i=6 */
   {0x1.c8p-1, 0x1.563dc2ap-3, -0x1.4d37cde37c86bp-41}, /* i=7 */
   {0x1.cp-1, 0x1.8a8980acp-3, -0x1.0b36665592075p-41}, /* i=8 */
   {0x1.cp-1, 0x1.8a8980acp-3, -0x1.0b36665592075p-41}, /* i=9 */
   {0x1.b8p-1, 0x1.bfc67a8p-3, -0x1.667f21fa8423fp-44}, /* i=10 */
   {0x1.bp-1, 0x1.f5fd8a906p-3, 0x1.f1a4847f7b278p-42}, /* i=11 */
   {0x1.bp-1, 0x1.f5fd8a906p-3, 0x1.f1a4847f7b278p-42}, /* i=12 */
   {0x1.a8p-1, 0x1.169c05364p-2, -0x1.d4f1b95e0ff45p-43}, /* i=13 */
   {0x1.ap-1, 0x1.32bfee371p-2, -0x1.1979a5db68722p-42}, /* i=14 */
   {0x1.ap-1, 0x1.32bfee371p-2, -0x1.1979a5db68722p-42}, /* i=15 */
   {0x1.98p-1, 0x1.4f6fbb2cfp-2, -0x1.d33c38d8bd28dp-41}, /* i=16 */
   {0x1.9p-1, 0x1.6cb0f6866p-2, -0x1.b8afe492bf6ffp-41}, /* i=17 */
   {0x1.9p-1, 0x1.6cb0f6866p-2, -0x1.b8afe492bf6ffp-41}, /* i=18 */
   {0x1.88p-1, 0x1.8a8980acp-2, -0x1.0b36665592075p-40}, /* i=19 */
   {0x1.8p-1, 0x1.a8ff97181p-2, 0x1.4bc302ffa76fbp-43}, /* i=20 */
   {0x1.8p-1, 0x1.a8ff97181p-2, 0x1.4bc302ffa76fbp-43}, /* i=21 */
   {0x1.78p-1, 0x1.c819dc2d4p-2, 0x1.7f90e25762b12p-40}, /* i=22 */
   {0x1.78p-1, 0x1.c819dc2d4p-2, 0x1.7f90e25762b12p-40}, /* i=23 */
   {0x1.7p-1, 0x1.e7df5fe54p-2, -0x1.d532c412ba94ep-40}, /* i=24 */
   {0x1.7p-1, 0x1.e7df5fe54p-2, -0x1.d532c412ba94ep-40}, /* i=25 */
   {0x1.68p-1, 0x1.042bd4b9a8p-1, -0x1.b3b3864c60011p-44}, /* i=26 */
};

/* For -71 <= j <= 34, T2[j+71] contains {r, h, l} such that
   for xmin := 1+j/2^12 <= x < xmax := 1+(j+1)/2^12 for j < 0,
       xmin := 1+j/2^11 <= x < xmax := 1+(j+1)/2^11 for 0 <= j,
   r is a 21-bit approximation minimizing max(abs(r*x-1))
   for xmin <= x < xmax,
   h approximates -log2(r) to nearest, with h multiple of 2^-38, and
   l approximates -log2(r)-h to nearest, with |h + l + log2(r)| < 2^-94.31.
   Ensures 0.999755859375000 <= r*x <= 1.00024402141571.
   Table generated by T2() from log2l.sage. */
static const double T2[106][3] = {
   {0x1.047bcp+0, -0x1.9a6151ecp-6, -0x1.19a0256cc7f15p-40}, /* i=-71 */
   {0x1.046b3p+0, -0x1.948232aap-6, -0x1.f1526b900108bp-40}, /* i=-70 */
   {0x1.045aap+0, -0x1.8ea2b3cdp-6, 0x1.8b1e6fcd4ace2p-40}, /* i=-69 */
   {0x1.044a2p+0, -0x1.88c8824p-6, 0x1.61dcc6e227a12p-42}, /* i=-68 */
   {0x1.04399p+0, -0x1.82e84462p-6, 0x1.373d8ca7ca961p-41}, /* i=-67 */
   {0x1.0429p+0, -0x1.7d07a6c3p-6, -0x1.c4c11f7c1b847p-41}, /* i=-66 */
   {0x1.04188p+0, -0x1.772c5766p-6, -0x1.eac5d68098ebbp-40}, /* i=-65 */
   {0x1.0408p+0, -0x1.7150a8eap-6, 0x1.5aa40c86550b4p-40}, /* i=-64 */
   {0x1.03f78p+0, -0x1.6b749b41p-6, 0x1.39459e7479c96p-40}, /* i=-63 */
   {0x1.03e7p+0, -0x1.65982e5fp-6, -0x1.fa4636681c768p-40}, /* i=-62 */
   {0x1.03d68p+0, -0x1.5fbb623ap-6, 0x1.dd03362e2bcfep-44}, /* i=-61 */
   {0x1.03c61p+0, -0x1.59e3e6ap-6, -0x1.937129365683cp-42}, /* i=-60 */
   {0x1.03b59p+0, -0x1.54065c2ap-6, -0x1.c69b60748291ep-42}, /* i=-59 */
   {0x1.03a52p+0, -0x1.4e2e22ep-6, -0x1.1b617da7d846ep-40}, /* i=-58 */
   {0x1.0394ap+0, -0x1.484fd9eap-6, 0x1.dce8f9950b33cp-40}, /* i=-57 */
   {0x1.03843p+0, -0x1.4276e2cp-6, 0x1.9f65baf8badf7p-40}, /* i=-56 */
   {0x1.0373cp+0, -0x1.3c9d8cc2p-6, 0x1.3ebeca38bcf66p-40}, /* i=-55 */
   {0x1.03635p+0, -0x1.36c3d7e4p-6, 0x1.98e0c76d000acp-41}, /* i=-54 */
   {0x1.0352fp+0, -0x1.30ef767cp-6, -0x1.309fdfd94b65cp-40}, /* i=-53 */
   {0x1.03428p+0, -0x1.2b150417p-6, 0x1.6f392ddba5da1p-41}, /* i=-52 */
   {0x1.03321p+0, -0x1.253a32adp-6, -0x1.35635c3c37734p-40}, /* i=-51 */
   {0x1.0321bp+0, -0x1.1f64b5abp-6, -0x1.0b1d35fdf8d18p-40}, /* i=-50 */
   {0x1.03115p+0, -0x1.198eda46p-6, 0x1.60cdcd488dec8p-42}, /* i=-49 */
   {0x1.0300fp+0, -0x1.13b8a071p-6, -0x1.4f8797e878a2cp-40}, /* i=-48 */
   {0x1.02f09p+0, -0x1.0de20822p-6, 0x1.c2a977868f235p-40}, /* i=-47 */
   {0x1.02e03p+0, -0x1.080b114bp-6, 0x1.5ccec2121e904p-40}, /* i=-46 */
   {0x1.02cfdp+0, -0x1.0233bbe1p-6, 0x1.56030492b4395p-40}, /* i=-45 */
   {0x1.02bf8p+0, -0x1.f8c37af2p-7, -0x1.2968c466193e1p-45}, /* i=-44 */
   {0x1.02af2p+0, -0x1.ed135642p-7, -0x1.bfceccdb0262p-40}, /* i=-43 */
   {0x1.029edp+0, -0x1.e16de0dap-7, -0x1.5fe6d81e9aeedp-44}, /* i=-42 */
   {0x1.028e8p+0, -0x1.d5c7af5ep-7, 0x1.fb38add588fe3p-40}, /* i=-41 */
   {0x1.027e2p+0, -0x1.ca15538ep-7, -0x1.43906dfc8f09ep-40}, /* i=-40 */
   {0x1.026dep+0, -0x1.be7917c8p-7, 0x1.3e0967952f1d6p-40}, /* i=-39 */
   {0x1.025d9p+0, -0x1.b2d0b18p-7, 0x1.7b34cb74c9f29p-40}, /* i=-38 */
   {0x1.024d4p+0, -0x1.a7278ec4p-7, 0x1.b778083d7f023p-43}, /* i=-37 */
   {0x1.023cfp+0, -0x1.9b7daf7ep-7, 0x1.0d85c2753cf71p-40}, /* i=-36 */
   {0x1.022cbp+0, -0x1.8fde8556p-7, 0x1.6353e510c250ep-40}, /* i=-35 */
   {0x1.021c7p+0, -0x1.843e9fe4p-7, -0x1.033ee8c09fca4p-44}, /* i=-34 */
   {0x1.020c3p+0, -0x1.789dff12p-7, -0x1.0cb6a592fa8aep-43}, /* i=-33 */
   {0x1.01fbep+0, -0x1.6cf12edep-7, 0x1.e2ceae5e769a8p-40}, /* i=-32 */
   {0x1.01ebbp+0, -0x1.615a8aeep-7, 0x1.791f8d6131606p-41}, /* i=-31 */
   {0x1.01db7p+0, -0x1.55b7b76cp-7, 0x1.7d3eecfa0858dp-43}, /* i=-30 */
   {0x1.01cb3p+0, -0x1.4a14282ap-7, -0x1.f3f9733ae16b4p-40}, /* i=-29 */
   {0x1.01bbp+0, -0x1.3e7b53ep-7, -0x1.47ab7b2d3d278p-40}, /* i=-28 */
   {0x1.01aacp+0, -0x1.32d64d94p-7, 0x1.4c8a5706423dbp-40}, /* i=-27 */
   {0x1.019a9p+0, -0x1.273c037ep-7, -0x1.ccf2bb047250ep-40}, /* i=-26 */
   {0x1.018a6p+0, -0x1.1ba0febep-7, -0x1.769ef679d6cbfp-41}, /* i=-25 */
   {0x1.017a3p+0, -0x1.10053f3ap-7, -0x1.1cb1944133595p-41}, /* i=-24 */
   {0x1.016ap+0, -0x1.0468c4dcp-7, 0x1.b2ff1bb3638d6p-40}, /* i=-23 */
   {0x1.0159dp+0, -0x1.f1971f14p-8, 0x1.0aa2d7bae5645p-40}, /* i=-22 */
   {0x1.0149ap+0, -0x1.da5b3e5cp-8, 0x1.06b848ed802fdp-41}, /* i=-21 */
   {0x1.01398p+0, -0x1.c334e088p-8, 0x1.2feb7b6579b04p-40}, /* i=-20 */
   {0x1.01295p+0, -0x1.abf6148cp-8, -0x1.1f40f732b83a4p-46}, /* i=-19 */
   {0x1.01193p+0, -0x1.94cccdf8p-8, -0x1.187d565368a61p-40}, /* i=-18 */
   {0x1.01091p+0, -0x1.7da21378p-8, -0x1.6838c078e068p-40}, /* i=-17 */
   {0x1.00f8fp+0, -0x1.6675e4ep-8, 0x1.b80a1e148176dp-40}, /* i=-16 */
   {0x1.00e8dp+0, -0x1.4f4841f8p-8, -0x1.0331eba6fbad8p-40}, /* i=-15 */
   {0x1.00d8bp+0, -0x1.38192a9cp-8, 0x1.236194cc061b7p-40}, /* i=-14 */
   {0x1.00c8ap+0, -0x1.20ffa1d4p-8, -0x1.fff0f191ca3f4p-43}, /* i=-13 */
   {0x1.00b88p+0, -0x1.09cda26cp-8, 0x1.fba2d3a683d8ep-40}, /* i=-12 */
   {0x1.00a87p+0, -0x1.e5626838p-9, -0x1.59fece10fb53dp-41}, /* i=-11 */
   {0x1.00986p+0, -0x1.b726a7p-9, 0x1.4d7ffd4884496p-40}, /* i=-10 */
   {0x1.00885p+0, -0x1.88e800cp-9, -0x1.b6a56beda55c4p-40}, /* i=-9 */
   {0x1.00784p+0, -0x1.5aa6753p-9, 0x1.5affdfa901fd5p-41}, /* i=-8 */
   {0x1.00683p+0, -0x1.2c6203ep-9, -0x1.16682f328aec6p-40}, /* i=-7 */
   {0x1.00582p+0, -0x1.fc3559p-10, -0x1.13f7573bd6a89p-41}, /* i=-6 */
   {0x1.00481p+0, -0x1.9fa0dd6p-10, 0x1.a7c84a6887abfp-41}, /* i=-5 */
   {0x1.00381p+0, -0x1.4362d5p-10, -0x1.92a60f29d17e7p-40}, /* i=-4 */
   {0x1.0028p+0, -0x1.cd85866p-11, -0x1.266e85b118f54p-40}, /* i=-3 */
   {0x1.0018p+0, -0x1.14f25dap-11, 0x1.4dbb8c1b7c8c9p-40}, /* i=-2 */
   {0x1.0008p+0, -0x1.714eb1p-13, -0x1.fa53637548e21p-41}, /* i=-1 */
   {0x1.ffep-1, 0x1.7160018p-12, -0x1.ce69aa0cd2408p-41}, /* i=0 */
   {0x1.ffa01p-1, 0x1.14eb20bp-10, 0x1.88bc7cba50fc1p-40}, /* i=1 */
   {0x1.ff603p-1, 0x1.cd671a7p-10, 0x1.7acee5e60f7e1p-40}, /* i=2 */
   {0x1.ff206p-1, 0x1.42e5f108p-9, -0x1.9cb47e5f2191bp-41}, /* i=3 */
   {0x1.fee0ap-1, 0x1.9f0cb5f8p-9, -0x1.99ed09d4022adp-40}, /* i=4 */
   {0x1.fea0fp-1, 0x1.fb27d64p-9, -0x1.b8a2bed7ecfd6p-40}, /* i=5 */
   {0x1.fe615p-1, 0x1.2b9ba608p-8, 0x1.7b86ca8f5c2a1p-40}, /* i=6 */
   {0x1.fe21cp-1, 0x1.599d88d8p-8, -0x1.e06be4f8e2aaep-40}, /* i=7 */
   {0x1.fde24p-1, 0x1.8799909cp-8, 0x1.c7d3648f0c368p-40}, /* i=8 */
   {0x1.fda2dp-1, 0x1.b58fba78p-8, 0x1.802423618ccd3p-40}, /* i=9 */
   {0x1.fd637p-1, 0x1.e380038p-8, 0x1.cc3f1653f935ap-40}, /* i=10 */
   {0x1.fd242p-1, 0x1.08b53468p-7, -0x1.580171297fda4p-40}, /* i=11 */
   {0x1.fce4ep-1, 0x1.1fa773bcp-7, -0x1.e1639d33e2ebep-42}, /* i=12 */
   {0x1.fca5bp-1, 0x1.3696be4ap-7, -0x1.4f9f0cab3ff03p-41}, /* i=13 */
   {0x1.fc668p-1, 0x1.4d88e264p-7, -0x1.1fabcbbdf4c4cp-41}, /* i=14 */
   {0x1.fc277p-1, 0x1.64723fbep-7, 0x1.12be7ea905b9ap-40}, /* i=15 */
   {0x1.fbe87p-1, 0x1.7b58a3f4p-7, -0x1.7be683784334dp-41}, /* i=16 */
   {0x1.fba98p-1, 0x1.923c0d8ep-7, -0x1.2f6950844d149p-40}, /* i=17 */
   {0x1.fb6aap-1, 0x1.a91c7b16p-7, 0x1.606f3bc56ad08p-45}, /* i=18 */
   {0x1.fb2bcp-1, 0x1.bfffbe7ap-7, 0x1.28bfad00475d5p-42}, /* i=19 */
   {0x1.faedp-1, 0x1.d6da3036p-7, 0x1.cb30d69c134e7p-41}, /* i=20 */
   {0x1.faae5p-1, 0x1.edb1a17ep-7, 0x1.dfab14dab4dfcp-41}, /* i=21 */
   {0x1.fa6fap-1, 0x1.0245f334p-6, 0x1.a0892404dc1e8p-43}, /* i=22 */
   {0x1.fa311p-1, 0x1.0daea98ep-6, -0x1.8fe6239fa7f33p-40}, /* i=23 */
   {0x1.f9f29p-1, 0x1.1915dd7ap-6, 0x1.33036bdf2c583p-40}, /* i=24 */
   {0x1.f9b41p-1, 0x1.247e7a1ap-6, -0x1.5e7d47fac33eep-40}, /* i=25 */
   {0x1.f975bp-1, 0x1.2fe2a755p-6, 0x1.18095e895b257p-40}, /* i=26 */
   {0x1.f9375p-1, 0x1.3b483c84p-6, 0x1.56ed4a4a3d7c5p-41}, /* i=27 */
   {0x1.f8f91p-1, 0x1.46a9601ep-6, 0x1.5b29efdf84118p-40}, /* i=28 */
   {0x1.f8badp-1, 0x1.520beaecp-6, -0x1.03b032dfdace1p-41}, /* i=29 */
   {0x1.f87cap-1, 0x1.5d6cef9cp-6, 0x1.04db20ce629c8p-40}, /* i=30 */
   {0x1.f83e9p-1, 0x1.68c97f6dp-6, 0x1.dc5b320f9fe04p-40}, /* i=31 */
   {0x1.f8008p-1, 0x1.74277551p-6, 0x1.cd28b53917896p-41}, /* i=32 */
   {0x1.f7c28p-1, 0x1.7f83e2e2p-6, -0x1.815ec06d1acc1p-40}, /* i=33 */
   {0x1.f7849p-1, 0x1.8adec762p-6, -0x1.525408d2c98bcp-40}, /* i=34 */
};

/* return in h+l an approximation of log2(xh + xl)
   for -0.000244140625 <= xh < 0.00024402141571 and 0 <= xl < 2^-37.49,
   with |l| < 2^-62.17 */
static void
P (double *h, double *l, double xh, double xl)
{
  /* The following is a degree-8 minimax polynomial for log2(1+x)
     over [-0.000244140625,0.00024402141571] generated by Sollya
     (file log2_fast.sollya), with no constant coefficient, double
     coefficients except that of degree 1 which is a double-double,
     and maximal absolute error 2^-84.514. */
  static const double p[] = {
    0x1.71547652b82fep+0, 0x1.777d10fa9419cp-56, // degree 1
    -0x1.71547652b82fep-1,                      // degree 2
    0x1.ec709dc3a03fbp-2,                       // degree 3
    -0x1.71547661d011fp-2,                      // degree 4
    0x1.2776c56eb6ca2p-2,                       // degree 5
    -0x1.bd761baf2853cp-3,                      // degree 6
    0x1.24996255a29ecp-3,                       // degree 7
    -0x1.6c9c75469b616p17,                      // degree 8
  };
  fast_two_sum_double (&xh, &xl, xh, xl);
  // now -0.000244140625 <= xh < 0.00024402141571 and |xl| < 2^-64
  double xx = xh * xh;
  double c7 = __builtin_fma (p[8], xh, p[7]);
  double c5 = __builtin_fma (p[6], xh, p[5]);
  c5 = __builtin_fma (c7, xx, c5);
  double c3 = __builtin_fma (p[4], xh, p[3]);
  c3 = __builtin_fma (c5, xx, c3);
  fast_two_sum_double (h, l, p[2], c3*xh);
  d_mul_double (h, l, *h, *l, xh, xl);
  double t;
  fast_two_sum_double (h, &t, p[0], *h);
  *l += t + p[1];
  // multiply h+l by xh+xl
  d_mul_double (h, l, *h, *l, xh, xl);

  /* From analyzeP() in log2l.sage, the absolute error is bounded by 2^-84.39:
     |h + l - log2(1 + xh + xl)| < 2^-84.39 */
}

/* put in h+l an approximation of e + log2(x) for 1 <= x < 2
   with |h + l - (e + log2(x))| < 2^-84.19 and |l| < 2^-36.99 */
static void
fast_path (double *h, double *l, long double x, int e)
{
  // if (x0 == TRACE) printf ("x=%La e=%d\n", x, e);
  /* convert x to double-double representation xh + xl, where xh is a
     multiple of 2^-38, thus is representable on 39 bits */
  b96u96_u v = {.f = x};
  b64u64_u th = {.u = (0x3fful<<52) | ((v.m >> 25) << 14)};
  b64u64_u tl = {.u = (0x3d9ul<<52) | ((v.m << 39) >> 12)};
  double xh = th.f, xl = tl.f - 0x1p-38;
  // 1 <= xh < 2 and 0 <= xl < 2^-38

  // if (x0 == TRACE) printf ("xh=%la xl=%la\n", xh, xl);

  int i = (th.u << 12) >> 58; // 0 <= i < 2^6
  if (i > 26)
  {
    xh = xh * 0.5;
    xl = xl * 0.5;
    e ++;
    i -= 64;
  }

  /* now 0.7109375 <= xh < 1.421875 and 0 <= xl < 2^-38;
     for 0 <= i <= 26 we have 1 <= xh + xl < 1.421875
     for -37 <= i <= -1 we have 0.7109375 <= xh + xl < 1 */
  const double *ti = T1[i + 37];
  xh *= ti[0]; // exact
  xl *= ti[0]; // rounding error < ulp(xl) <= 2^-90
  // if (x0 == TRACE) printf ("i=%d xh=%la xl=%la\n", i, xh, xl);
  
  /* since xh was multiple of 2^-38 and ti[0] is multiple of 2^-6,
     xh is now multiple of 2^-44 */

  // now 0.982666015625000 < xh < 1.01684570312500 and 0 <= xl < 2^-37.5

  th.f = xh;
  int j = (th.u >> 41) - 0x1ff800; // -71 <= j <= 34
  assert (-71 <= j && j <= 34);

  /* For -32 <= j < 0, we have 1 + j/2^12 <= x < 1 + (j+1)/2^12;
     for 0 <= j < 16, we have 1 + j/2^12 <= x < 1 + (j+1)/2^11.
     Since xh is multiple of 2^-44 and tj[0] is multiple of 2^-21,
     xh*tj[0] is multiple of 2^-65.
     Since 0.999755859375000 < xh < 1.00024402141571, xh-1 is exactly
     representable on 53 bits. */
  const double *tj = T2[j + 71];
  // if (x0 == TRACE) printf ("xh=%la tj[0]=%la\n", xh, tj[0]);
  xh = __builtin_fma (xh, tj[0], -1.0); // exact
  xl *= tj[0]; // rounding error < ulp(xl) <= 2^-90
  /* Let xl0 be the initial value of xl, xl1 the value after xl *= ti[0],
     and xl2 the value after xl *= tj[0]: we have xl1 = xl*t1[0] + eps1
     with |eps1| < 2^-90, and xl2 = xl1*tj[0] + eps2 with |eps2| < 2^-90,
     thus xl2 = xl*t1[0]*tj[0] + eps1*tj[0] + eps2, with
     |eps1*tj[0] + eps2| < 2^-90*(0x1.01fbep+0 + 1) < 2^-88.99. */
  *h = (double) e + ti[1] + tj[1]; // exact since tx[1] multiples of 2^-38
  *l = ti[2] + tj[2];
  /* Since |ti[2]|, |tj[2]| < 2^-39, we have |l| < 2^-38, and the rounding
     error on l is bounded by 2^-90. */
  // if (x0 == TRACE) printf ("j=%d h=%la l=%la xh=%la xl=%la\n", j, *h, *l, xh, xl);
  
  /* now xh + xl represents tj[0]*ti[0]*x - 1, with
     -0.000244140625 <= xh < 0.00024402141571 and 0 <= xl < 2^-37.49 */

  double ph, pl;
  P (&ph, &pl, xh, xl); // absolute error < 2^-84.39
  // if (x0 == TRACE) printf ("ph=%la pl=%la\n", ph, pl);
  double t;
  fast_two_sum_double (h, &t, *h, ph);
  *l += t + pl; /* The rounding error is bounded by ulp(t+pl) + ulp(l).
                   Since |h| < 16445, we have |t| < ulp(h) <= 2^-38,
                   |pl| < 2^-62.17 thus ulp(t+pl) <= ulp(2^-37.99) = 2^-90,
                   and since we had |l| < 2^-38, the new value of l is
                   bounded by 2^-38 + 2^-37.99 < 2^-36.99, thus
                   ulp(l) <= ulp(2^-36.99) = 2^-89. */

  // if (x0 == TRACE) printf ("h=%la l=%la\n", *h, *l);
  
  /* We have the following errors:
   * error on P() bounded by 2^-84.39
   * error on ti[1] + ti[2] + log2(ti[0]) bounded by 2^-97.91
   * error on tj[1] + tj[2] + log2(tj[0]) bounded by 2^-94.31
   * error on l = ti[2] + tj[2] bounded by 2^-90
   * induced error in P() since xl might be wrong by up to 2^-88.99:
     this is bounded by the derivative of the minimax polynomial times
     2^-88.99, which is < 1.45 * 2^-88.99 < 2^-88.45
   * rounding error on *l += t + pl bounded by 2^-90 + 2^-89
   The total error is thus bounded by:
   2^-84.39 + 2^-97.91 + 2^-94.31 + 2^-90 + 2^-88.45 + 2^-90 + 2^-89 < 2^-84.19
   */
}

/* given h, l with |h + l - log2(x)| < 2^-84,
   return non-zero if o(h+l) = o(log2(x)) as a long double */
static int
rounding_test (double h, double l)
{
  /* we have |l| < 2^-36.99, and we want to know if l-err and l+err
     round to the same value, for err = 0x1.c1p-85 < 2^-84 */
  b64u64_u th = {.f = h}, tl = {.f = l};
  int eh = (th.u << 1) >> 53; // unbiased exponent
  int el = (tl.u << 1) >> 53; // unbiased exponent, el <= 986
  int lbits = 64 - (eh - el); // number of bits of l contributing to result
                              // when h+l is considered as long double
  int rb = 52 - lbits;        // position in l of the (final result) round bit
  /* for 2^-37 <= |l| < 2^-36, i.e., el=986, 2^-84 corresponds to 2^5 ulps,
     thus for any el it corresponds to 2^(991-el) ulps */
  int sh = 991 - el; // 2^-84 corresponds to 2^sh ulp(l), with sh >= 5
  if (sh >= rb || lbits < 0)
    /* If sh >= rb, adding/subtracting 2^sh will modify the round bit.
       If lbits < 0, l is so tiny that only contributes to result,
       in this case we cannot round for directed modes. */
    return 0;
  /* Now sh < rb, and since sh >= 5, this means 5 < rb.
     We can round (for all rounding modes) if when adding or subtracting
     2^sh ulps from l, bit rb does not change, i.e., if all bits from
     sh to rb-1 are different from 000...000 or 111...111. */

  // since lbits >= 0, rb <= 52
  // since sh < rb and rb <= 52, sh < 52 (and also 5 <= sh)
  uint64_t g = tl.u >> sh;
  uint64_t mask = (1ul << (rb - sh)) - 1ul;
  g = g & mask;
  return g != 0 && g != mask;
}

long double
cr_log2l (long double x)
{
  b96u96_u t = {.f = x};
  // if (x == TRACE) printf ("e=%x m=%lx\n", t.e, t.m);
  int ex = t.e, e = ex - 0x3fff;
  if (__builtin_expect(!ex, 0)) // x=+0 or positive subnormal
  {
    if (!t.m) return (long double) -1.0 / 0.0; // x=+0
    int k = __builtin_clzll (t.m);
    e -= k - 1;
    t.m <<= k;
  }
  if (__builtin_expect(ex >= 0x7fff, 0)) // x<=0 or Inf or NaN
  {
    if (!t.m) return (long double) -1.0 / 0.0; // x=-0
    if (t.m == (1ul << 63) && (ex == 0x7fff)) return x; // x=+Inf
    return 0.0 / 0.0; // x < 0 or qNaN or sNaN
  }

  t.e = 0x3fff; // normalize t.f in [1,2)

  // now x is normal and x > 0, x = t.m/2^63 * 2^e
  if (__builtin_expect(t.m>>63==0, 0)) return as_log2_exact(e);

  double h, l;
  fast_path (&h, &l, t.f, e);
  if (rounding_test (h, l))
    return (long double) h + (long double) l;

  /* FIXME: when removing -1 here, also remove the check in check_special.c
     and .. /support/check_worst_uni.c */
  return -1;
}
